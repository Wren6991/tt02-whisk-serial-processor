#include <iostream>
#include <fstream>
#include <cstdint>
#include <string>
#include <stdio.h>

// Device-under-test model generated by CXXRTL:
#include "dut.cpp"
#include <backends/cxxrtl/cxxrtl_vcd.h>

// -----------------------------------------------------------------------------

static const int MEM_SIZE = 64 * 1024;

typedef enum {
	SPI_CMD,
	SPI_ADDR,
	SPI_DATA,
	SPI_BADCMD
} spi_sram_state_t;

class SPISRAM {
	spi_sram_state_t state;
	uint8_t cmd;
	uint32_t addr;
	uint8_t wdata;
	uint bit_ctr;
	bool prev_sck;
	bool prev_sdo;
public:
	uint32_t size;
	uint8_t *mem;

	SPISRAM(uint32_t size_) {
		size = size_;
		addr = 0;
		state = SPI_CMD;
		bit_ctr = 0;
		prev_sck = false;
		prev_sdo = false;
		mem = new uint8_t[size];
		for (uint32_t i = 0; i < size; ++i)
			mem[i] = 0;
	}

	// return: sdo (bool)
	bool step(bool csn, bool sck, bool sdi) {
		if (csn) {
			state = SPI_CMD;
			addr = 0;
			bit_ctr = 0;
			prev_sdo = false;
			prev_sck = sck;
			return false;
		}
		bool sdo = prev_sdo;
		if (sck && !prev_sck) {
			bit_ctr += 1;
			switch (state) {
			case SPI_CMD: {
				cmd = (cmd << 1) | sdi;
				if (bit_ctr == 8) {
					bit_ctr = 0;
					addr = 0;
					if (cmd == 0x03 || cmd == 0x02) {
						state = SPI_ADDR;
					} else {
						state = SPI_BADCMD;
					}
				}
				break;
			}
			case SPI_ADDR: {
				addr = (addr << 1) | sdi;
				if (bit_ctr == 16) {
					state = SPI_DATA;
					bit_ctr = 0;
					addr = addr % size;
				}
				break;
			}
			case SPI_DATA: {
				if (cmd == 0x02) {
					wdata = (wdata << 1) | sdi;
					if (bit_ctr == 8) {
						bit_ctr = 0;
						mem[addr] = wdata;
						addr = (addr + 1) % size;
					}
				}
				break;
			}
			case SPI_BADCMD: {
				break;
			}
			}
		} else if (!sck && prev_sck) {
			if (state == SPI_DATA) {
				if (cmd == 0x03) {
					sdo = (mem[addr] >> (7 - bit_ctr)) & 0x1u;
					if (bit_ctr == 7) {
						bit_ctr = -1;
						addr = (addr + 1) % size;
					}
				}
			}
		}

		prev_sdo = sdo;
		prev_sck = sck;
		return sdo;
	}
};

class IOPort {
	uint16_t shiftout;
	uint8_t shiftin;
	bool prev_sck;
	bool prev_latch_o;
	uint16_t out_history[3];
public:
	bool exitcode_valid;
	uint16_t exitcode;

	IOPort() {
		shiftout = 0;
		shiftin = 0;
		prev_sck = false;
		prev_latch_o = true;
		for (int i = 0; i < 3; ++i) {
			out_history[i] = 0;
		}
		exitcode_valid = false;
		exitcode = 0;
	}

	bool step(bool sck, bool sdi, bool latch_i, bool latch_o) {
		if (sck && !prev_sck) {
			shiftout = (shiftout >> 1) | (sdi << 15);
			shiftin = shiftin >> 1;
		}
		if (latch_o && !prev_latch_o) {
			out_history[2] = out_history[1];
			out_history[1] = out_history[0];
			out_history[0] = shiftout;
			printf("OUT: %04x\n", shiftout);
			if (out_history[2] == 0x7357 && out_history[1] == 0xdead) {
				exitcode_valid = true;
				exitcode = out_history[0];
			}
		}
		prev_sck = sck;
		prev_latch_o = latch_o;
		return shiftin & 0x1u;
	}
};

// -----------------------------------------------------------------------------

const char *help_str =
"Usage: tb [--bin x.bin] [--vcd x.vcd] [--dump start end] \\\n"
"          [--cycles n]\n"
"\n"
"    --bin x.bin      : Flat binary file loaded to address 0x0 in RAM\n"
"    --vcd x.vcd      : Path to dump waveforms to\n"
"    --dump start end : Print out memory contents from start to end (exclusive)\n"
"                       after execution finishes. Can be passed multiple times.\n"
"    --cycles n       : Maximum number of cycles to run before exiting.\n"
"                       Default is 0 (no maximum).\n"
;

void exit_help(std::string errtext = "") {
	std::cerr << errtext << help_str;
	exit(-1);
}

int main(int argc, char **argv) {

	bool load_bin = false;
	std::string bin_path;
	bool dump_waves = false;
	std::string waves_path;
	std::vector<std::pair<uint32_t, uint32_t>> dump_ranges;
	int64_t max_cycles = 0;

	for (int i = 1; i < argc; ++i) {
		std::string s(argv[i]);
		if (s.rfind("--", 0) != 0) {
			std::cerr << "Unexpected positional argument " << s << "\n";
			exit_help("");
		}
		else if (s == "--bin") {
			if (argc - i < 2)
				exit_help("Option --bin requires an argument\n");
			load_bin = true;
			bin_path = argv[i + 1];
			i += 1;
		}
		else if (s == "--vcd") {
			if (argc - i < 2)
				exit_help("Option --vcd requires an argument\n");
			dump_waves = true;
			waves_path = argv[i + 1];
			i += 1;
		}
		else if (s == "--dump") {
			if (argc - i < 3)
				exit_help("Option --dump requires 2 arguments\n");
			dump_ranges.push_back(std::pair<uint32_t, uint32_t>(
				std::stoul(argv[i + 1], 0, 0),
				std::stoul(argv[i + 2], 0, 0)
			));;
			i += 2;
		}
		else if (s == "--cycles") {
			if (argc - i < 2)
				exit_help("Option --cycles requires an argument\n");
			max_cycles = std::stol(argv[i + 1], 0, 0);
			i += 1;
		}
		else {
			std::cerr << "Unrecognised argument " << s << "\n";
			exit_help("");
		}
	}
	if (!load_bin)
		exit_help("--bin is not optional.\n");

	SPISRAM sram(MEM_SIZE);
	IOPort io;

	if (load_bin) {
		std::ifstream fd(bin_path, std::ios::binary | std::ios::ate);
		if (!fd){
			std::cerr << "Failed to open \"" << bin_path << "\"\n";
			return -1;
		}
		std::streamsize bin_size = fd.tellg();
		if (bin_size > MEM_SIZE) {
			std::cerr << "Binary file (" << bin_size << " bytes) is larger than memory (" << MEM_SIZE << " bytes)\n";
			return -1;
		}
		fd.seekg(0, std::ios::beg);
		fd.read((char*)sram.mem, bin_size);
	}

	cxxrtl_design::p_whisk__top top;

	std::ofstream waves_fd;
	cxxrtl::vcd_writer vcd;
	if (dump_waves) {
		waves_fd.open(waves_path);
		cxxrtl::debug_items all_debug_items;
		top.debug_info(all_debug_items);
		vcd.timescale(1, "us");
		vcd.add(all_debug_items);
	}

	// Reset + initial clock pulse

	top.step();
	top.p_io__clk.set<bool>(true);
	top.step();
	top.p_io__clk.set<bool>(false);
	top.p_io__rst__n.set<bool>(true);
	top.step();
	top.step(); // workaround for github.com/YosysHQ/yosys/issues/2780

	bool timed_out = false;
	bool mem_sdi_next = false;
	bool ioport_sdi_next = false;
	for (int64_t cycle = 0; cycle < max_cycles || max_cycles == 0; ++cycle) {
		top.p_io__clk.set<bool>(false);
		top.step();
		top.step(); // workaround for github.com/YosysHQ/yosys/issues/2780
		top.p_io__mem__sdi.set<bool>(mem_sdi_next);
		top.p_io__ioport__sdi.set<bool>(ioport_sdi_next);

		// SDI update is delayed to model scan chain tick on TT2
		mem_sdi_next = sram.step(
			top.p_io__mem__csn.get<bool>(),
			top.p_io__mem__sck.get<bool>(),
			top.p_io__mem__sdo.get<bool>()
		);
		ioport_sdi_next = io.step(
			top.p_io__ioport__sck.get<bool>(),
			top.p_io__ioport__sdo.get<bool>(),
			top.p_io__ioport__latch__i.get<bool>(),
			top.p_io__ioport__latch__o.get<bool>()
		);

		if (dump_waves) {
			top.step(); // Make SDI look right in the waves
			vcd.sample(cycle * 2);
		}

		top.p_io__clk.set<bool>(true);
		top.step();
		top.step(); // workaround for github.com/YosysHQ/yosys/issues/2780
		top.p_io__mem__sdi.set<bool>(mem_sdi_next);
		top.p_io__ioport__sdi.set<bool>(ioport_sdi_next);

		mem_sdi_next = sram.step(
			top.p_io__mem__csn.get<bool>(),
			top.p_io__mem__sck.get<bool>(),
			top.p_io__mem__sdo.get<bool>()
		);
		ioport_sdi_next = io.step(
			top.p_io__ioport__sck.get<bool>(),
			top.p_io__ioport__sdo.get<bool>(),
			top.p_io__ioport__latch__i.get<bool>(),
			top.p_io__ioport__latch__o.get<bool>()
		);

		if (dump_waves) {
			top.step(); // Make SDI look right in the waves
			vcd.sample(cycle * 2 + 1);
			waves_fd << vcd.buffer;
			vcd.buffer.clear();
		}

		if (io.exitcode_valid) {
			printf("CPU requested halt. Exit code %d\n", io.exitcode);
			printf("Ran for %ld cycles\n", cycle + 1);
			break;
		}
		if (cycle + 1 == max_cycles) {
			printf("Max cycles reached\n");
			timed_out = true;
		}
	}

	for (auto r : dump_ranges) {
		printf("Dumping memory from %08x to %08x:\n", r.first, r.second);
		for (int i = 0; i < r.second - r.first; ++i)
			printf("%02x%c", sram.mem[r.first + i], i % 16 == 15 ? '\n' : ' ');
		printf("\n");
	}

	return 0;
}
